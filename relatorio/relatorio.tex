\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{amssymb}

\geometry{a4paper, left=3cm, right=2cm, top=3cm, bottom=2cm}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

\title{Relatório de Projeto: Compilador SL - Etapa 1}
\author{
    Gustavo Zacarias de Souza \\
    Matrícula: 22.1.4112 \\
    Luiz Eduardo Fugliaro \\
    Matrícula: 22.1.4014 \\ \\
    BCC328 - Construção de Compiladores I - DECOM/UFOP
}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Este relatório documenta a primeira etapa do desenvolvimento de um compilador para a linguagem SL, focando nas fases de análise léxica e sintática. O projeto, implementado em Haskell, utiliza as ferramentas Alex e Happy para a geração dos analisadores. O sistema resultante é capaz de processar tokens complexos, tratar comentários aninhados, resolver ambiguidades gramaticais e gerar uma Árvore de Sintaxe Abstrata (AST) rica, capaz de representar construções como \textit{generics}, \textit{structs} e funções de alta ordem. Além disso, foram implementados módulos de visualização (\textit{TreeUtils}) e formatação de código (\textit{Pretty Printer}).
\end{abstract}

\tableofcontents

\newpage

\section{Introdução}
A linguagem SL é uma linguagem imperativa estaticamente tipada que visa combinar simplicidade com recursos modernos, como polimorfismo paramétrico e funções como cidadãos de primeira classe. O objetivo deste trabalho é construir, em etapas, um compilador completo para SL com alvo em WebAssembly.

Nesta Etapa 1, o escopo limita-se ao \textit{frontend} do compilador, abrangendo:
\begin{itemize}
    \item Definição formal dos Tokens e implementação do Lexer.
    \item Definição da Gramática Livre de Contexto e implementação do Parser.
    \item Definição da Árvore de Sintaxe Abstrata (AST).
    \item Utilitários de visualização (impressão da árvore e reconstrução de código).
\end{itemize}

\section{Metodologia}

\subsection{Estrutura sintática de SL}
A gramática foi desenhada para suportar construções de alto nível. Baseando-se no arquivo \texttt{Parser.y} e \texttt{AST.hs}, a estrutura divide-se em:
\begin{itemize}
    \item \textbf{Declarações de Topo (\texttt{TopDecl}):} O programa é uma sequência de declarações que podem ser funções (\texttt{func}) ou estruturas de dados (\texttt{struct}).
    \item \textbf{Generics:} Funções podem declarar parâmetros de tipo utilizando a palavra-chave \texttt{forall} (ex: \texttt{forall a. func map...}).
    \item \textbf{Comandos (\texttt{Stmt}):} Inclui declarações de variáveis (\texttt{let}), atribuições, estruturas de controle (\texttt{if}, \texttt{while}, \texttt{for}) e retorno.
    \item \textbf{Açúcar Sintático:} O parser realiza transformações diretas ("desaçúcaramento"). Por exemplo, o incremento \texttt{i++} no laço \texttt{for} é convertido internamente para \texttt{i = i + 1}, e a declaração de arrays com inicialização é convertida para uma alocação \texttt{new}.
\end{itemize}

\subsection{Sistema de tipos para SL}
Embora a verificação semântica não faça parte desta etapa, a AST (\texttt{AST.hs}) já define a estrutura completa de tipos suportada pela linguagem:
\begin{itemize}
    \item \textbf{Primitivos:} \texttt{TyInt}, \texttt{TyFloat}, \texttt{TyBool}, \texttt{TyString}, \texttt{TyVoid}.
    \item \textbf{Arrays:} \texttt{TyArray Type} (ex: \texttt{int[]}).
    \item \textbf{Customizados:} \texttt{TyCustom String} (para Structs).
    \item \textbf{Variáveis de Tipo:} \texttt{TyVar String} (para Generics).
    \item \textbf{Tipos de Função:} \texttt{TyFunc [Type] Type} (ex: \texttt{(int, int) -> bool}), permitindo suporte a funções de alta ordem.
\end{itemize}

\subsection{Inferência de tipos para SL}
\textit{Implementação prevista para a próxima etapa (Análise Semântica).}

\subsection{Semântica operacional para SL}
\textit{Implementação prevista para as etapas futuras (Geração de Código).}

\section{Arquitetura do Compilador}

\subsection{Análise léxica (\texttt{Lexer.x} e \texttt{Tokens.hs})}
O analisador léxico foi gerado pelo \textbf{Alex}. A definição dos tokens (\texttt{Tokens.hs}) inclui suporte a coordenadas de arquivo (linha e coluna) para relatórios de erro precisos.

\subsubsection{Decisão de Projeto: \texttt{monadUserState} vs \texttt{posn}}

Durante o desenvolvimento do analisador léxico, considerou-se inicialmente o uso do wrapper \texttt{posn}, que fornece automaticamente informações de linha e coluna para cada token. No entanto, optou-se pelo uso do wrapper \texttt{monadUserState}, pois ele oferece maior flexibilidade ao permitir a manutenção de um estado explícito durante a análise léxica.

Essa decisão foi motivada principalmente pela necessidade de suportar comentários de bloco aninhados. Com \texttt{monadUserState}, foi possível manter um contador de profundidade de comentários, algo que não seria trivial de implementar apenas com \texttt{posn}. Além disso, o uso de um estado explícito facilita futuras extensões do lexer, como controle de contexto ou modos léxicos adicionais.

Apesar disso, as informações de posição (linha e coluna) ainda são preservadas e associadas aos tokens, garantindo mensagens de erro precisas.

\subsubsection{Decisão de Projeto: Precedência Explícita em Tipos Complexos}

Durante a definição da gramática para o sistema de tipos, surgiu um conflito de \textit{shift/reduce} crítico envolvendo a interação entre tipos de função e tipos de array. O analisador sintático encontrou ambiguidade ao processar construções como \texttt{int[] -> int}, incerto se deveria reduzir o array imediatamente ou empilhar o operador de função.

Para solucionar este impasse, optou-se por definir explicitamente a precedência do token \texttt{->} utilizando a diretiva \texttt{\%right}, atribuindo-lhe uma prioridade inferior à dos colchetes. Diferente de tentar reestruturar as regras da gramática — o que poderia tornar a AST desnecessariamente complexa —, o uso de diretivas de precedência mostrou-se uma solução mais limpa e eficiente.

Essa decisão foi motivada pela necessidade de garantir a associatividade correta em cadeias de funções (\textit{Currying}), onde \texttt{a -> b -> c} deve ser interpretado como \texttt{a -> (b -> c)}. Simultaneamente, a baixa prioridade assegura que modificadores de tipo mais fortes, como arrays, sejam aplicados antes da formação do tipo função, eliminando o conflito e garantindo a interpretação semântica correta.\\
\\ \\

\textbf{Destaque Técnico: Comentários Aninhados}
Para suportar comentários de bloco que podem conter outros comentários (\texttt{/* ... /* ... */ ... */}), utilizou-se o wrapper \texttt{monadUserState} do Alex. Isso permitiu manter um estado interno (\texttt{lexerCommentDepth}) para contagem de profundidade. O lexer alterna entre o \textit{start code} \texttt{<0>} (código normal) e \texttt{<comment>} (dentro de comentário), garantindo que o comentário só termine quando a profundidade retornar a zero.

\subsection{Análise sintática (\texttt{Parser.y})}
O analisador sintático foi gerado pelo \textbf{Happy}. A gramática resolveu ambiguidades cruciais através de precedência de operadores:
\begin{itemize}
    \item \textbf{Dangling Else:} Resolvido via \texttt{\%expect 1}, instruindo o parser a preferir o \textit{shift} (associar o \texttt{else} ao \texttt{if} mais interno).
    \item \textbf{Tipo Função vs Array:} A ambiguidade na declaração \texttt{(int) -> int[]} (função que retorna array ou array de funções?) foi resolvida atribuindo maior precedência ao token \texttt{[} (\texttt{\%left}) em relação à seta \texttt{->} (\texttt{\%right}).
\end{itemize}

\subsection{Árvore de sintaxe abstrata (\texttt{AST.hs} e \texttt{TreeUtils.hs})}
A AST é composta por tipos algébricos de dados (ADTs) que representam a estrutura hierárquica do programa.
O módulo auxiliar \texttt{TreeUtils.hs} foi implementado para converter essa AST proprietária em uma \texttt{Data.Tree} genérica do Haskell. Isso permite o uso da função \texttt{drawTree}, gerando uma visualização ASCII hierárquica e legível da estrutura sintática quando a flag \texttt{--parser} é acionada.

\subsection{Pretty Printing (\texttt{Pretty.hs})}
O módulo \texttt{Pretty.hs} utiliza a biblioteca \texttt{Text.PrettyPrint} para converter a AST de volta em código fonte SL. Este módulo lida com a indentação correta de blocos aninhados e formatação de expressões complexas, servindo como uma ferramenta de validação para garantir que a AST capturou corretamente todas as informações do código original.

\subsection{Análise semântica}
\textit{Trabalho futuro.}

\subsection{Geração de código}
\textit{Trabalho futuro.}

\section{Resultados e Discussão}

\subsection{Instruções de Uso e Compilação}
O projeto inclui um arquivo \texttt{.cabal} configurado com as dependências (\texttt{array}, \texttt{containers}, \texttt{pretty}, \texttt{alex}, \texttt{happy}).
Para compilar e executar, utiliza-se:

\begin{lstlisting}[language=bash]
# Compilar o projeto
cabal build

# Executar o parser visualizando a arvore
cabal run sl-compiler -- --parser src/tests/test4_generics.sl

# Executar o pretty printer
cabal run sl-compiler -- --pretty src/tests/test4_generics.sl
\end{lstlisting}

Os testes foram totalmente automatizados por meio de um \texttt{Makefile}. O comando \texttt{make test} executa sequencialmente todos os casos de teste definidos, interrompendo a execução caso algum erro seja encontrado. Essa abordagem garante reprodutibilidade e facilita a validação contínua do compilador à medida que novas funcionalidades são adicionadas.


Foi criado um arquivo \texttt{commands} na raiz do projeto contendo todos os comandos utilizados durante o desenvolvimento, compilação e execução do compilador. Esse arquivo serve como documentação prática do fluxo de trabalho adotado e facilita a reprodução dos experimentos realizados.

O relatório foi escrito em \LaTeX{} e sua geração foi automatizada por meio de um \texttt{Makefile} localizado no diretório \texttt{relatorio}. A compilação do PDF pode ser realizada simplesmente com o comando \texttt{make}, garantindo facilidade de uso e padronização na entrega do trabalho.


\subsection{Testes Realizados}
O compilador foi validado com um conjunto de 6 arquivos de teste, cobrindo:
\begin{enumerate}
    \item \texttt{test1.sl}: Estruturas básicas de controle e aritmética.
    \item \texttt{test2\_structs.sl}: Declaração e acesso a campos de registros.
    \item \texttt{test3\_arrays.sl}: Manipulação de vetores.
    \item \texttt{test4\_generics.sl}: Funções genéricas e tipos de função.
    \item \texttt{test5\_comments.sl} e \texttt{test6\_multcomm.sl}: Testes de estresse do lexer para comentários aninhados e ignorar espaços em branco.
\end{enumerate}

Todos os testes passaram com sucesso, gerando as árvores sintáticas esperadas e reconstruindo o código corretamente via \textit{pretty printing}.

\subsection{Limitações}
A verificação de tipos (ex: impedir soma de \texttt{int} com \texttt{bool}) e verificação de escopo (variáveis não declaradas) ainda não são realizadas, pois pertencem à fase de Análise Semântica.

\section{Conclusão}
A etapa de análise léxica e sintática foi concluída com sucesso. A escolha de Haskell permitiu uma representação concisa e segura da AST. O uso de \textit{monadUserState} no Lexer resolveu de forma elegante a complexidade dos comentários aninhados, e o Parser gerado é robusto o suficiente para lidar com as características avançadas da linguagem SL, como generics e funções de alta ordem. A infraestrutura de \textit{Pretty Printing} e visualização de árvore (\textit{TreeUtils}) facilita a depuração e validação do compilador nas próximas etapas.

\section{Referências}

\begin{thebibliography}{9}
\bibitem{hutton2016}
Hutton, G. (2016). \emph{Programming in Haskell}. Cambridge University Press.

\bibitem{alex}
Dornan, C., et al. \emph{Alex: A lexical analyser generator for Haskell}. Disponível em: https://haskell.org/alex/

\bibitem{happy}
Marlow, S., et al. \emph{Happy: The Parser Generator for Haskell}. Disponível em: https://haskell.org/happy/

\bibitem{wadler}
Wadler, P. \emph{A prettier printer}. The Fun of Programming, Cornerstones of Computing. 2003.

\bibitem{webassembly2023}
WebAssembly Community Group. (2023). \emph{WebAssembly Specification}.
\end{thebibliography}

\end{document}